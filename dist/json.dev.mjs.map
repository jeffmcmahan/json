{
  "version": 3,
  "sources": ["../src/tokenize.src.ts", "../src/tokenize.ts", "../src/types/AstNode.ts", "../src/constructs/string.ts", "../src/constructs/number.ts", "../src/constructs/null.ts", "../src/constructs/array.ts", "../src/constructs/object.ts", "../src/main.src.ts"],
  "sourcesContent": ["import {Token} from './types/Token.ts'\n\n/** Fast, simple src string segmentation. */\nexport const tokenize = (src: string): Token[] => {\n\tlet pos = 0\n\tconst tokens: Token[] = []\n\twhile (pos < src.length) {\n\t\tconst token = src[pos]\n\n\t\t// Step past whitespace.\n\t\tif ([' ', '\\t', '\\n'].includes(token)) {\n\t\t\tpos++\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === 'n' && src.slice(pos, pos + 4) === 'null') {\n\t\t\ttokens.push({\n\t\t\t\ttoken: 'null',\n\t\t\t\ttype: 'null'\n\t\t\t})\n\t\t\tpos += 4\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === '{') {\n\t\t\ttokens.push({\n\t\t\t\ttoken, \n\t\t\t\ttype: 'leftBrace'\n\t\t\t})\n\t\t\tpos++\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === '}') {\n\t\t\ttokens.push({\n\t\t\t\ttoken, \n\t\t\t\ttype: 'rightBrace'\n\t\t\t})\n\t\t\tpos++\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === ',') {\n\t\t\ttokens.push({\n\t\t\t\ttoken, \n\t\t\t\ttype: 'comma'\n\t\t\t})\n\t\t\tpos++\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === ':') {\n\t\t\ttokens.push({\n\t\t\t\ttoken, \n\t\t\t\ttype: 'colon'\n\t\t\t})\n\t\t\tpos++\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === '[') {\n\t\t\ttokens.push({\n\t\t\t\ttoken,\n\t\t\t\ttype: 'leftBracket'\n\t\t\t})\n\t\t\tpos++\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === ']') {\n\t\t\ttokens.push({\n\t\t\t\ttoken,\n\t\t\t\ttype: 'rightBracket'\n\t\t\t})\n\t\t\tpos++\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === '\"') {\n\t\t\tconst onset = pos\n\t\t\tlet offset = pos\n\t\t\tdo {\n\t\t\t\toffset++\n\t\t\t} while (src[offset] !== '\"' && src[offset - 1] !== '\\\\')\n\n\t\t\ttokens.push({\n\t\t\t\ttoken: src.slice(onset, offset + 1),\n\t\t\t\ttype: 'string'\n\t\t\t})\n\n\t\t\tpos = (offset + 1)\n\t\t\tcontinue\n\t\t}\n\n\t\tif ('0123456789'.includes(token)) {\n\t\t\tconst onset = pos\n\t\t\tlet offset = pos\n\t\t\twhile ('0123456789.'.includes(src[offset])) {\n\t\t\t\toffset++\n\t\t\t}\n\t\t\tconst token = src.slice(onset, offset)\n\t\t\ttokens.push({token, type: 'number'})\n\t\t\tif (!token.match(/^\\d+(.\\d+)?$/)) {\n\t\t\t\tthrow new SyntaxError(`Invalid number: ${token}`)\n\t\t\t}\n\t\t\tpos = offset\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn tokens\n}", "import {tokenize} from './tokenize.src.ts'\nexport {tokenize} from './tokenize.src.ts'\n\nconst tokens = tokenize(`[\n\t11,\n\t\"2\",\n\t{\"three\": null},\n]`)\n\nconsole.assert(\n\ttokens[0].type === 'leftBracket',\n\t'Should spot opening array bracket.'\n)\n\nconsole.assert(\n\ttokens[1].type === 'number',\n\t'Should spot the first array element (11).'\n)\n\nconsole.assert(\n\ttokens[1].token === '11',\n\t'Should have the number 11 as a string in .value.'\n)\n\nconsole.assert(\n\ttokens[2].type === 'comma',\n\t'Should register the comma delimeter.'\n)\n\nconsole.assert(\n\ttokens[3].type === 'string',\n\t'Should spot the string: \"2\".'\n)\n\nconsole.assert(\n\ttokens[3].token === '\"2\"',\n\t'Should have the string value in including the quotes.'\n)\n\nconsole.assert(\n\ttokens[5].type === 'leftBrace',\n\t'Should spot the opening brace for the embedded object.'\n)\n\nconsole.assert(\n\ttokens[7].type === 'colon',\n\t'Should spot the property assignment colon.'\n)\n\nconsole.assert(\n\ttokens[8].type === 'null',\n\t'Should spot the null value at array[2].three.'\n)\n\nconsole.assert(\n\ttokens[9].type === 'rightBrace',\n\t'Should spot the closing brace.'\n)\n\nconsole.assert(\n\ttokens[11].type === 'rightBracket',\n\t'Should spot the closing bracket.'\n)", "type NodeTypeName = (\n\t'root' | 'null' | 'string' | 'number' | 'array' | 'object' | \n\t'property' | 'propertyName' | 'propertyValue'\n)\n\nexport class AstNode {\n\n\ttype: NodeTypeName\n\tvalue: string\n\tchildren: AstNode[]\n\tparent: AstNode\n\n\tconstructor(type: NodeTypeName, parent?: AstNode) {\n\t\tthis.type = type\n\t\tthis.value = ''\n\t\tthis.children = []\n\t\tthis.parent = (parent ?? this)\n\t\tif (parent) {\n\t\t\tparent.children.push(this)\n\t\t}\n\t}\n\n\t/** Traverses the tree to retrieve the value at the given path.  */\n\tstatic lookup(ast: AstNode, path: string): AstNode {\n\t\t\n\t\tconst segments: string[]  = path.split('.')\n\t\tlet host = ast\n\t\twhile (segments.length) {\n\n\t\t\t// Collect the object and property nodes\n\t\t\tconst propNodes: AstNode[] = []\n\t\t\thost.children.forEach((astNode: AstNode) => {\n\t\t\t\tif (astNode.type === 'property') {\n\t\t\t\t\tpropNodes.push(astNode)\n\t\t\t\t}\n\t\t\t\tif (astNode.type === 'object') {\n\t\t\t\t\tpropNodes.push(...astNode.children)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// propNodes.forEach(node => console.log(AstNode.print(node)))\n\n\t\t\t// Get the current path segment.\n\t\t\tconst segment: string = (segments.shift() ?? '')\n\n\t\t\t// Grab the property node with the matching name.\n\t\t\tconst foundNode = propNodes.find((astNode: AstNode) => {\n\t\t\t\treturn astNode.children[0].value === `\"${segment}\"`\n\t\t\t})\n\n\t\t\t// Hard fail on a bad path.\n\t\t\tif (!foundNode) {\n\t\t\t\tthrow new TypeError(`Path \"${path}\" lookup failed at: .${segment}`)\n\t\t\t}\n\n\t\t\thost = foundNode.children[1].children[0] // Update the host node context.\n\t\t}\n\n\t\treturn host\n\t}\n\n\t/** Recursively serializes the AST structure. */\n\tprivate static _print(ast: AstNode, depth: number): string {\n\t\tconst indent = '\\n' + ''.padStart((depth * 2), ' ')\n\t\treturn (\n\t\t\tindent + '- ' +\n\t\t\tast.type + ': ' +\n\t\t\tast.value + // <- Often empty.\n\t\t\tast.children.map((child: AstNode) => AstNode._print(child, depth + 1)).join('')\n\t\t)\n\t}\n\n\t/** Adapts the _print method for public exposure. */\n\tpublic static print(ast: AstNode): string {\n\t\treturn AstNode._print(ast, 0)\n\t}\n}", "import {State} from '../types/State.ts'\nimport {AstNode} from '../types/AstNode.ts'\n\nexport const parseString = (state: State) => {\n\tif (state.tokens[state.pos].type === 'string') {\n\t\tconst stringNode = new AstNode('string', state.host)\n\t\tstringNode.value = state.tokens[state.pos].token\n\t\tstate.pos++ // Step past the string literal.\n\t}\n}", "import {State} from '../types/State.ts'\nimport {AstNode} from '../types/AstNode.ts'\n\nexport const parseNumber = (state: State) => {\n\tif (state.tokens[state.pos].type === 'number') {\n\t\tconst numNode = new AstNode('number', state.host)\n\t\tnumNode.value = state.tokens[state.pos].token\n\t\tstate.pos++ // Step past the number literal.\n\t}\n}", "import {State} from '../types/State.ts'\nimport {AstNode} from '../types/AstNode.ts'\n\nexport const parseNull = (state: State) => {\n\tif (state.tokens[state.pos].token === 'null') {\n\t\tconst stringNode = new AstNode('null', state.host)\n\t\tstringNode.value = 'null'\n\t\tstate.pos++ // Step past null.\n\t}\n}", "import {State} from '../types/State.ts'\nimport {AstNode} from '../types/AstNode.ts'\nimport {parseString} from './string.ts'\nimport {parseNumber} from './number.ts'\nimport {parseObject} from './object.ts'\nimport {parseNull} from './null.ts'\n\n/** Parses: `<object|array|string|number>, ...` */\nconst parseElement = (state: State) => {\n\n\tif (state.tokens[state.pos].type !== 'rightBracket') {\n\t\tconst nextTokenType = state.tokens[state.pos].type\n\t\tif (nextTokenType === 'leftBrace') {\n\t\t\tparseObject(state)\n\t\t} else if (nextTokenType === 'leftBracket') {\n\t\t\tparseArray(state)\n\t\t} else if (nextTokenType === 'string') {\n\t\t\tparseString(state)\n\t\t} else if (nextTokenType === 'number') {\n\t\t\tparseNumber(state)\n\t\t} else if (nextTokenType === 'null') {\n\t\t\tparseNull(state)\n\t\t}\n\n\t\t// If next token is a comma, recur.\n\t\tif (state.tokens[state.pos].type === 'comma') {\n\t\t\tstate.pos++ // Step past the comma.\n\t\t\tparseElement(state)\n\t\t}\n\t}\n}\n\nexport const parseArray = (state: State) => {\n\n\tif (state.tokens[state.pos].type === 'leftBracket') {\n\t\tconst arrayNode = new AstNode('array', state.host)\n\t\tstate.host = arrayNode\n\t\tstate.pos++ // Step past the opening bracket.\n\n\t\t// Iterate until the parser stops handling tokens.\n\t\twhile (state.tokens[state.pos].type !== 'rightBracket') {\n\t\t\tparseElement(state)\n\t\t}\n\t\t\n\t\tstate.host = arrayNode.parent\n\t\tstate.pos++ // Step past closing bracket.\n\t}\n}", "import {State} from '../types/State.ts'\nimport {AstNode} from '../types/AstNode.ts'\nimport {parseString} from './string.ts'\nimport {parseNumber} from './number.ts'\nimport {parseArray} from './array.ts'\nimport {parseNull} from './null.ts'\n\n/** Parses: `\"propName\": <object|array|string|number>,` */\nconst parseProperty = (state: State) => {\n\n\tif (state.tokens[state.pos].type === 'string') {\n\t\t\n\t\t// Create the property node and then the name and value nodes.\n\t\tconst propNode = new AstNode('property', state.host)\n\t\tconst propNameNode = new AstNode('propertyName', propNode)\n\t\tconst propValueNode = new AstNode('propertyValue', propNode)\n\t\tpropNameNode.value = state.tokens[state.pos].token\n\t\tstate.pos++ // Step past the property name.\n\t\tstate.pos++ // Step past the assignment colon.\n\n\t\t// Get the value of the property.\n\t\tstate.host = propValueNode\n\t\tconst nextTokenType = state.tokens[state.pos].type\n\t\tif (nextTokenType === 'leftBrace') {\n\t\t\tparseObject(state)\n\t\t} else if (nextTokenType === 'leftBracket') {\n\t\t\tparseArray(state)\n\t\t} else if (nextTokenType === 'string') {\n\t\t\tparseString(state)\n\t\t} else if (nextTokenType === 'number') {\n\t\t\tparseNumber(state)\n\t\t} else if (nextTokenType === 'null') {\n\t\t\tparseNull(state)\n\t\t}\n\n\t\t// Step out of the property node context, back to the object node.\n\t\tstate.host = propNode.parent\n\n\t\t// If next token is a comma, recur.\n\t\tif (state.tokens[state.pos].type === 'comma') {\n\t\t\tstate.pos++ // Step past the comma.\n\t\t\tparseProperty(state)\n\t\t}\n\t}\n}\n\nexport const parseObject = (state: State) => {\n\n\tif (state.tokens[state.pos].type === 'leftBrace') {\n\t\tconst objNode = new AstNode('object', state.host)\n\t\tstate.host = objNode\n\t\tstate.pos++ // Step past the opening brace.\n\n\t\twhile (state.tokens[state.pos].type !== 'rightBrace') {\n\t\t\tparseProperty(state)\n\t\t}\n\n\t\tstate.host = objNode.parent\n\t\tstate.pos++ // Step past closing brace.\n\t}\n}", "import {tokenize} from './tokenize.ts'\nimport {Token} from './types/Token.ts'\nimport {State} from './types/State.ts'\nimport {AstNode} from './types/AstNode.ts'\nimport {parseObject} from './constructs/object.ts'\nimport {parseArray} from './constructs/array.ts'\nimport {parseString} from './constructs/string.ts'\nimport {parseNumber} from './constructs/number.ts'\nimport {parseNull} from './constructs/null.ts'\n\nconst parseTokens = (tokens: Token[]): AstNode => {\n\t\n\tconst root = new AstNode('root')\n\tconst state: State = {\n\t\ttokens,\n\t\tpos: 0,\n\t\tast: root,\n\t\thost: root\n\t}\n\n\t// The root-level context is special; it tolerates a lone value\n\t// of any datatype.\n\n\twhile (state.pos < tokens.length) {\n\t\t\n\t\tconst start = state.pos\n\n\t\tparseNumber(state)\n\t\tif (state.pos > start) {\n\t\t\tbreak // If top-level number, we're done.\n\t\t}\n\t\t\n\t\tparseString(state)\n\t\tif (state.pos > start) {\n\t\t\tbreak // If top-level string, we're done.\n\t\t}\n\n\t\tparseNull(state)\n\t\tif (state.pos > start) {\n\t\t\tbreak // If top-level null, we're done.\n\t\t}\n\n\t\tparseArray(state)\n\t\tif (state.pos > start) {\n\t\t\tbreak\n\t\t}\n\n\t\tparseObject(state)\n\t\tif (state.pos > start) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn state.ast\n}\n\n/** Consumes JSON source and produces a syntax tree. */\nexport const parse = (src: string): AstNode => {\n\tconst tokens: Token[] = tokenize(' ' + src + ' ')\n\tconst tree: AstNode = parseTokens(tokens)\n\treturn tree\n}"],
  "mappings": "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",
  "names": []
}
